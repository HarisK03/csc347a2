<html>
	<body>
		<h1> # FIX OWASP A8: CSRF (Cross Site Request Forgery) </h1>
		<h2> The Vulnerability </h2>
		<ul>
			<li> Brief explanation:
<xmp>
CSRF is a vulnerability that lets attackers trick users into doing unwanted actions while authenticated. It works since 
browsers automatically send session cookies with every request regardless of where the request is coming from. With no additional verifications, the server can't tell the difference 
between a legit user request or fake ones.
</xmp>
			</li>
			<li> Example code etc.:
<xmp>
The deleteExpression operation is processed solely on session cookies

} elseif($operation == "deleteExpression"){
    $expressionId = $_REQUEST['expressionId'];
    $accountId=$_REQUEST['accountId']; 
    $dbconn = pg_connect_db();
    $result = pg_prepare($dbconn, "", "DELETE FROM solution WHERE id=$expressionId AND accountId=$accountId");
    $result = pg_execute($dbconn, "", array());
}

Without other validation means any request with a valid session cookie will be processed.
</xmp>
			</li>
			<li> How attacker exploits this: 
<xmp>
We can embed a malicious request in an image tag like in lectures or a link:

<img src="http://192.168.10.35/fourFours/index.php?operation=deleteExpression&expressionId=5&accountId=8" 
     width="0" height="0" />

When a logged in user views a page with this code via email or website, their browser automatically submits the request along with their session cookie, 
and without the knowledge or permission of the user, the server confirms the request and removes the expression.
</xmp>
			</li>
			<li> Impact: CIAaa and some details
<xmp>
C: Users' private information is exposed to unauthorized access and modification
I: Attackers can alter the integrity of the system like adding/deleting content or modifying account settings
A: Attackers can delete user data or disrupt user operations

This is easily detectable but also easily exploitable if users are authenticated with only session cookies.
</xmp>
			</li>
		</ul>

		<h2> INSTRUCTIONS TO VERIFY VULNERABILITY BELOW </h2>
<xmp>
1. Login to http://192.168.10.35/fourFours/ and create an expression
2. Hover over the delete icon and copy the URL ?operation=deleteExpression&expressionId=123&accountId=1
3. Create a file called malicious.html with this content:

   <html><body>
   <img src="http://192.168.10.35/fourFours/index.php?operation=deleteExpression&expressionId=5&accountId=8" 
        width="0" height="0" />
   </body></html>

4. While still logged in, open malicious.html in the same browser
5. Return to the application and the expression is deleted without your knowledge
</xmp>
		<h2> The Fix </h2>
		<ul>
			<li> Explain the fix: 
<xmp>
We implement a CSRF protection by:

1. (line 18):
   if(!isset($_SESSION['csrf_token']))$_SESSION['csrf_token'] = md5(random_bytes(32));
   
   Create a random token which is stored in the session.

2. (lines 19-25):
   function verifyCSRFToken(){
       if(!isset($_REQUEST['csrf_token']) || $_REQUEST['csrf_token'] !== $_SESSION['csrf_token']){
           global $g_errors;
           $g_errors = "Request rejected due to invalid CSRF token.";
           return false;
       }
       return true;
   }
   
   Validate that submitted tokens match the session token.

3. Apply the verification to all state-changing operations:
   if($operation == "login" && verifyCSRFToken()){
   if($operation == "deleteExpression" && verifyCSRFToken()){
   if($operation == "addExpression" && verifyCSRFToken()){
   if($operation == "logout" && verifyCSRFToken()){

4. Include the token in forms/links:
   <input type="hidden" name="csrf_token" value="<?=$_SESSION['csrf_token']?>"/>
   <a href="?operation=logout&csrf_token=<?=$_SESSION['csrf_token']?>">
</xmp>
			</li>
			<li> How the fix resolves the issue:
<xmp>
The fix ensures that every request to the server needs to include both a valid session cookie and a matching CSRF token.
Browser will still send the victim's session cookie, but the attacker can't include the CSRF token as they don't know it.
The server checks both the cookie and token, and if the token is missing or invalid, the request is rejected.

The token is stored server side in the session and can't be accessed by external sites due to Same-Origin Policy.
</xmp>
			</li>
		</ul>
	</body>
</html>
