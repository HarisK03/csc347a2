<html>
	<body>
		<h1> # FIX OWASP 2013 A1: SQL Injection, use prepared statements </h1>
		<h2> The Vulnerability </h2>
		<ul>
			<li> Brief explanation:
<xmp>
SQL injection occurs when the app puts user input into SQL queries without sanitization. The code uses pg_prepare but the input is concatenated into the query string before preparing it which defeats the purpose of prepared statements.
</xmp>
			</li>
			<li> Example code etc.:
<xmp>
The vulnerable code concatenates user input into the query:

(line 48-54)
$user=$_REQUEST['user'];
$password=$_REQUEST['password'];
$dbconn = pg_connect_db();
$query= "SELECT id, username, firstName, lastName, passwd FROM account WHERE username='$user'";
$result = pg_prepare($dbconn, "", $query);
$result = pg_execute($dbconn, "", array());

The $user variable is inserted into the query directly making it vulnerable to SQL injection.
</xmp>
			</li>
			<li> How attacker exploits this: 
<xmp>
The attacker exploits this by:

1. Going to http://192.168.10.35/fourFours/ login page

2. Entering this as the username:
   hi' OR '1'='1';--

3. Entering any password

4. The SQL query becomes:
   SELECT id, username, firstName, lastName, passwd FROM account WHERE username='hi' OR '1'='1';--

5. Since '1'='1' is always true the query returns all users and logs in as the first user without knowing the password
</xmp>
			</li>
			<li> Impact: CIAaa and some details
<xmp>
C: Attackers can read any data from the database such as passwords and user information
I: The attacker can modify or delete records using UPDATE or DELETE statements in the attack
A: The attacker can drop tables or entire database making all user information unavailable

SQL injection allows complete control of the database. We can bypass authentication, modify records, or destroy the database.
</xmp>
			</li>
		</ul>

		<h2> INSTRUCTIONS TO VERIFY VULNERABILITY BELOW </h2>
<xmp>
1. Visit http://192.168.10.35/fourFours/ login page

2. Enter this as username: test' OR '1'='1';--

3. Enter any password

4. You will be logged in without valid credentials

Vulnerable because we don't use parameterized queries.
</xmp>
                <h2> The Fix </h2>
                <ul>
                        <li> Explain the fix:
<xmp>
We fix this by using proper parameterized queries with placeholders:

$user=$_REQUEST['user'];
$password=$_REQUEST['password'];
$dbconn = pg_connect_db();
$result = pg_prepare($dbconn, "", "SELECT id, username, firstName, lastName, passwd FROM account WHERE username=$1");
$result = pg_execute($dbconn, "", array($user));

The $1 is a placeholder and the user value is passed separately in the array to pg_execute.
</xmp>
                        </li>
                        <li> How the fix resolves the issue:
<xmp>
This fix prevents SQL injection by separating SQL code from data. When we use parameterized queries the database treats the input as literal data and not code.

Now when we submit test' OR '1'='1';-- with the fix the database treats the entire string as a literal username to search for, and will look for a user named "test' OR '1'='1;--" which doesnt exist.
The placeholder $1 tells the database this is a parameter and pg_execute will safely pass the value.
</xmp>
                        </li>
                </ul>

	</body>
</html>
